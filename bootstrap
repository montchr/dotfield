#!/usr/bin/env bash
#
#
#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#::   \\\
#:: ======>      DOTFIELD PROVISIONER        ○
#::   ///
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>
#
#
# Thanks:
#   - https://github.com/d12frosted/environment
#   - https://github.com/alrra/dotfiles
#   - https://github.com/jasonheecs/ubuntu-server-setup
#

# shellcheck disable=2153
[[ -n "$ZSH_VERSION" ]] \
  && emulate -L bash


set -e


: "${DOTFIELD_HOSTNAME:=}"
: "${DOTFIELD_NIX_HOSTNAME:=${DOTFIELD_HOSTNAME}}"
: "${DOTFIELD_USERNAME:=montchr}"
: "${DOTFIELD_ID_EMAIL:=}"
: "${DOTFIELD_USER_PASSWORD:=}"
: "${DOTFIELD_SSH_PUBLIC_KEY:=}"
: "${DOTFIELD_TIMEZONE:=America/New_York}"

: "${USE_HTTPS:-true}"

DOTFIELD_BRANCH="${GITHUB_HEAD_REF:-${GITHUB_REF:-${DOTFIELD_BRANCH:-feature/nix-home-manager}}}"
DOTFIELD_BRANCH="${DOTFIELD_BRANCH#refs/heads/}"
readonly DOTFIELD_BRANCH

# TODO
# readonly QUERENT="${GITHUB_ACTOR:-montchr}"
readonly QUERENT="${DOTFIELD_USERNAME:-montchr}"
readonly REPO_ID="montchr/dots"
readonly DOTFIELD_RAW_BASE_URL="https://raw.githubusercontent.com/${REPO_ID}/${DOTFIELD_BRANCH}"
readonly DOTFIELD_LOCK_FILE="${XDG_CACHE_HOME:-${HOME}/.cache}/dotfield/dotfield.lock"

[[ -z "${DOTFIELD_NIX_HOSTNAME}" ]] \
  && DOTFIELD_NIX_HOSTNAME="$(hostname)"

: "${DOTFIELD:=${HOME}/.config}"
: "${XDG_CONFIG_HOME:=${DOTFIELD}}"

export \
  DOTFIELD \
  DOTFIELD_BRANCH \
  DOTFIELD_HOSTNAME \
  DOTFIELD_NIX_HOSTNAME \
  DOTFIELD_SSH_PUBLIC_KEY \
  DOTFIELD_TIMEZONE \
  DOTFIELD_USER_PASSWORD \
  DOTFIELD_USERNAME \
  HOSTNAME \
  QUERENT \
  REPO_ID \
  XDG_CONFIG_HOME


#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#:
#:    ==>   HELPER FUNCTIONS
#:
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>


#========================================
# Download file from a URL.
#
# Usage:
#   download <url> <dest-path>
# Arguments:
#   URL
#   Destination path
# Returns:
#   0 - Download succeeded.
#   1 - Download failed.
#========================================
function download {
  local url="$1"
  local output="$2"
  if command -v "curl" &>/dev/null; then
    curl -LsSo "$output" "$url" &>/dev/null
    return $?
  elif command -v "wget" &>/dev/null; then
    wget -qO "$output" "$url" &>/dev/null
    return $?
  fi
  return 1
}


#========================================
# Source a Dotfield file, falling back to sourcing ephemerally from the remote.
#
# Usage:
#   source_ephemeral <relative-path> [local-base]
# Arguments:
#   Relative path to file
#   Local mirror base directory
# Returns:
#   0 - Sourcing succeeded.
#   1 - Sourcing failed.
#========================================
function source_ephemeral {
  local path="$1"
  local local_mirror="${2-}"
  local filename
  local tmp_file=""
  local src_file=""

  if [[ -f "${path}" ]]; then
    # shellcheck disable=1090
    . "${path}" \
      && return
  fi

  filename="$(basename "${path}")"
  tmp_file="$(mktemp "/tmp/${filename}.XXXX")"

  if [[ -n "${local_mirror}" ]]; then
    src_file="${local_mirror}/${path}"
    echo "$src_file -> ${tmp_file}"
    cp -f "${src_file}" "${tmp_file}"
  else
    src_file="${DOTFIELD_RAW_BASE_URL}/${path}"
    echo "$src_file -> ${tmp_file}"
    download "${src_file}" "${tmp_file}"
  fi

  # shellcheck disable=1090
  . "${tmp_file}"
}


#========================================
# Verify whether the current OS version is supported by this script.
#
# Globals:
#   OS_NAME
#   OS_VERSION
# Outputs:
#   Feedback on error.
# Returns:
#   0 - Supported.
#   1 - Unsupported.
#========================================
function verify_os {
  declare -A Names Versions
  local supported_version

  Names=(
    [macos]="macOS"
    [ubuntu]="Ubuntu"
  )

  Versions=(
    [macos]="10.10"
    [ubuntu]="20.04"
  )

  supported_version="${Versions[$OS_NAME]}"

  if [[ -z "$supported_version" ]]; then
    echo "Sorry, your OS is not supported!"
    return 1
  fi

  str::is_supported_version \
    "${OS_VERSION}" \
    "${supported_version}" \
      && return 0

  printf "Sorry, this script is intended only for %s %s+" \
    "${Names[$OS_NAME]}" \
    "${supported_version}"
  return 1
}


#========================================
# Delete the bootstrap lockfile.
#
# Globals:
#   DOTFIELD_LOCK_FILE
#========================================
function lock__disengage {
  [[ -f "${DOTFIELD_LOCK_FILE}" ]] \
    && rm -rf "${DOTFIELD_LOCK_FILE}"
}


#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#:
#:    ==>   ERROR HANDLING + TRACEBACKS
#:
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>
#
# https://docwhat.org/tracebacks-in-bash
#


trap _exit_trap EXIT
trap _err_trap ERR
__DID_TRACEBACK=f

function _exit_trap() {
  local _ec="$?"
  if [[ $_ec != 0 && ${__DID_TRACEBACK} != t ]]; then
    traceback 1
  fi
  lock__disengage
}

function _err_trap() {
  local _ec="$?"
  local _cmd="${BASH_COMMAND:-unknown}"
  traceback 1
  __DID_TRACEBACK=t
  echo "The command ${_cmd} exited with exit code ${_ec}." 1>&2
  lock__disengage
}

function traceback() {
  # Hide the traceback() call.
  local -i start=$((${1:-0} + 1))
  local -i end=${#BASH_SOURCE[@]}
  local -i i=0
  local -i j=0

  echo "Traceback (last called is first):" 1>&2
  for ((i = start; i < end; i++)); do
    j=$((i - 1))
    local function="${FUNCNAME[$i]}"
    local file="${BASH_SOURCE[$i]}"
    local line="${BASH_LINENO[$j]}"
    echo "     ${function}() in ${file}:${line}" 1>&2
  done
}


#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#:
#:    ==>   INITIALIZATION
#:
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>


if [[ -f "${XDG_CONFIG_HOME}/lib/utils.sh" ]]
then

# shellcheck source=./lib/utils.sh
. "${XDG_CONFIG_HOME}/lib/utils.sh"

msg::stream::story <<END
We arrive at a well-travelled outcropping,
overlooking a familiar vista.

Let's get a closer look…
END

else

source_ephemeral "lib/utils.sh" "${DOTFIELD_TEST_BASE:-}"
msg::stream::story <<END
This world is beautiful, but dark.

Let's get our bearings and see what we can see
in the land below…
END

fi


msg::domain "System" "Verifying system state"
# shellcheck source=./vendor/pfetch/pfetch
"${XDG_CONFIG_HOME}/vendor/pfetch/pfetch"


# Ensure the OS is supported and above the minimum version.
# @TODO validation function doesn't work for older versions of bash and neither do associative arrays
# verify_os || return 1


msg::domain "System" "Syncing dotfield with ${XDG_CONFIG_HOME}"
msg::stream::story <<END
One cannot simply lift oneself up by one's own bootstraps...
END
repo::sync "${XDG_CONFIG_HOME}" "gh" "${REPO_ID}" "${DOTFIELD_BRANCH}" || exit 1


msg::domain "Travelling" "-> ${XDG_CONFIG_HOME}"
cd "${XDG_CONFIG_HOME}" || {
msg::stream::errors <<END
We seem to be lost in '$(pwd)'.
Something went wrong!

The world fades to black as we dematerialize…
END
exit 1
}


#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#:
#:    ==>   PREPARATION
#:
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>


msg::domain "Supporting" "Defining variables"

ALL="true"
ACTION=""
case $1 in
  install|upgrade|test)
    ACTION=$1
    shift
    ;;
  *)
    if [[ -z "$1" ]]; then
      ACTION=install
    else
      msg::error "action '$1' is not supported"
      msg::info "supported actions are: install, upgrade, test"
      exit 1
    fi
    ;;
esac

POSITIONAL=()
while [[ $# -gt 0 ]]
do
  if [[ -n "$1" ]]; then
    if [[ "$1" = -* ]]; then
      key=$(str::lower "${1#-}")
      declare -r "guard_ignore_${key}=true"
    else
      key=$(str::lower "$1")
      declare -r "guard_${key}=true"
      ALL="false"
    fi
  fi
  shift
done
set -- "${POSITIONAL[@]}" # restore positional parameters
export ALL
export ACTION


msg::domain "Supporting" "Checking for lockfile"

if [[ -f "${DOTFIELD_LOCK_FILE}" ]]
then

msg::stream::errors <<END
Yet another world is being shaped by Eru

One must either wait patiently
or embrace the horrors of the unknown
and manually delete the lockfile:

:: ${DOTFIELD_LOCK_FILE}
END

exit 1
fi

msg::domain "Supporting" "Engaging lock"
mkdir -p "$(dirname "${DOTFIELD_LOCK_FILE}")"
touch "${DOTFIELD_LOCK_FILE}"

# trap lock__disengage INT TERM EXIT


#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#:
#:    ==>   EXPECTATION
#:
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>



guard::macos && {
  if ! shell::is_modern; then
    msg::domain "Packages" "Install Homebrew and modern Bash"
    # shellcheck source=./os/macos/_pre_install.sh
    . "${XDG_CONFIG_HOME}/os/macos/_pre_install.sh"
  fi
}


guard::install && {
  msg::domain "Hostname" "Set the system hostname" && {
    if [[ -n "${DOTFIELD_HOSTNAME}" ]]; then
      HOSTNAME="${DOTFIELD_HOSTNAME}"
    else
      msg::ask "Enter a name: "
      HOSTNAME="$(msg::get_answer)"
      DOTFIELD_NIX_HOSTNAME="${HOSTNAME}"
    fi
  }
}


guard::install && {

  (shell::has nix nix-build nix-channel nix-env nix-shell) || {
    msg::domain "Nix" "Install Nix package manager"
    sh <(curl -L https://nixos.org/nix/install) --darwin-use-unencrypted-nix-store-volume --daemon
    if [[ ! -d /run ]]; then
      msg::warning "Directory '/run' does not exist, but multi-user Nix requires it."
      # msg::warning "Symlinking "
      # echo runtprivate/var/run | sudo tee -a /etc/synthetic.conf
      # /System/Library/Filesystems/apfs.fs/Contents/Resources/apfs.util -B
      # /System/Library/Filesystems/apfs.fs/Contents/Resources/apfs.util -t
    fi
    # TODO: automate
    msg::error "Unfortunately, you'll have to open a new shell and re-run the bootstrap script to get Nix working!"
    exit 1
  }

  # msg::subdomain "Install Nix Flakes" && {
  #   nix-env -iA nixpkgs.nixFlakes
  #   nix_flakes_feature_flag="experimental-features = nix-command flakes"
  #   if ! grep --quiet --fixed-strings "${nix_flakes_feature_flag}" /etc/nix/nix.conf; then
  #     msg::warning "Adding nix flakes feature flag to /etc/nix/nix.conf"
  #     echo "${nix_flakes_feature_flag}" | sudo tee -a /etc/nix/nix.conf
  #   fi
  # }
}


msg::domain "Travelling" "-> ${XDG_CONFIG_HOME}/nixpkgs"
cd "${XDG_CONFIG_HOME}/nixpkgs" || exit 1

msg::domain "Nix" "Build" && {
  guard::macos && {
    # Note that flakes must be flagged on either via a flag passed to the
    # command or via `~/.config/nix/nix/conf`. I've chosen the latter approach.
    nix build "./#${DOTFIELD_NIX_HOSTNAME}" \
      && "${DOTFIELD}/result/sw/bin/darwin-rebuild" switch --flake "./#${DOTFIELD_NIX_HOSTNAME}"
  }

  guard::linux && {
    # TODO: does this work anywhere besides NixOS?
    sudo nixos-rebuild switch --flake "./#${DOTFIELD_NIX_HOSTNAME}"
  }

}



# TODO: for testing nix only
exit 0






msg::domain "Guardian" "Ensure directories exist"
fs::ensure_dir "${XDG_BIN_HOME}"
fs::ensure_dir "$DEVELOPER"
fs::ensure_dir "$HOME/org"
fs::ensure_dir "$HOME/org/gtd"
fs::ensure_dir "$HOME/org/mind"
fs::ensure_dir "$HOME/org/roam"


guard::domain "Repo" "Sync repos from Repofiles" && {
  fs::map_lines repo::sync "${XDG_CONFIG_HOME}/Repofile" || true
  # @TODO file doesn't exist. what's this for?
  fs::map_lines repo::sync "${XDG_CACHE_HOME}/dotfield/Repofile" || true
}


guard::domain "Link" "Link all files as defined in Linkfiles" && {
  fs::linkfile "${DOTFIELD}/Linkfile"
  for f in "${DOTFIELD}"/**/Linkfile; do
    fs::linkfile "$f";
  done
  for f in "${DOTFIELD}"/**/Linkfile."${KERNEL_NAME}"; do
    fs::linkfile "$f"
  done
}


# guard::domain "Link" "Link all files from module bin directories" && {

#   for f in "${DOTFIELD}/*/bin/*"; do
#     link "$f" "${XDG_BIN_HOME}/$(basename "$f")"
#   done

# }


#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#:
#:    ==>   INSTALLATION + CONFIGURATION
#:
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>


guard::arch && {
  msg::domain "OS" "Installing Arch Linux environment"
  # shellcheck source=./os/arch/install
  . "${XDG_CONFIG_HOME}/os/arch/install"
}

guard::ubuntu && {
  msg::domain "OS" "Installing Ubuntu environment"
  # shellcheck source=./os/ubuntu/main
  . "${XDG_CONFIG_HOME}/os/ubuntu/main"
}

guard::macos && {

  msg::domain "OS" "Installing macOS environment"
  # shellcheck source=./os/macos/main
  . "${XDG_CONFIG_HOME}/os/macos/main"

  msg::domain "OS" "Configuring macOS preferences"
  "${XDG_CONFIG_HOME}/os/macos/configure"

}


guard::install && {
  msg::domain "Guardian" "Decrypting Dotfield secrets"
  if [[ $(gpg --list-secret-keys "${DOTFIELD_ID_EMAIL}" 2>/dev/null) ]]; then
    transcrypt --yes --import-gpg="${XDG_CONFIG_HOME}/.transcrypt"
  fi
}


guard::install && {
  msg::domain "Editor" "Installing Doom Emacs" && {
    [[ ! -d "${HOME}/.emacs.d" ]] && {
      git clone --depth 1 https://github.com/hlissner/doom-emacs "${HOME}/.emacs.d"
    }
    # TODO: the shell environment should reflect the user's login shell
    # environment, not the environment this script was run within. this might not
    # normally matter, but it could have a confusing effect if this was only run
    # during initial bootstrapping
    # ~/.emacs.d/bin/doom install
  }


  guard::domain "php" "Install Composer" && {
    # shellcheck source=./composer/install
    . "${XDG_CONFIG_HOME}/composer/install"
  }


  guard::domain "espanso" "Install Espanso" && {
    # shellcheck source=./espanso/install
    . "${XDG_CONFIG_HOME}/espanso/install"
  }


  guard::domain "firefox" "Install Tridactyl" && {
    # shellcheck source=./firefox/install_tridactyl
    . "${XDG_CONFIG_HOME}/firefox/install_tridactyl"
  }


  guard::domain "zsh" "Use XDG for ZSH" && {
    msg::subdomain "Copying" "zshenv -> ${HOME}/.zshenv"
    cp zshenv "${HOME}/.zshenv"
  }


  guard::macos && {
    guard::domain "firefox" "Link user chrome directory into existing profiles" && {
      for d in "${HOME}/Library/Application Support/Firefox/Profiles"/*
      do
        fs::link "${XDG_CONFIG_HOME}/firefox/chrome" "${d}/chrome"
      done
    }
  }
}


guard::upgrade && {
  # @TODO run in login shell! see previous note
  guard::domain "emacs" "Upgrading Doom Emacs" && {
    doom upgrade
  }
}


guard::macos && {

  # guard::domain "skhd" "Patch skhd application PATH" && {
  #   shell::has skhd && {
  #     # @TODO update this?
  #     "${DOTFIELD}/bin/patch_skhd_path"
  #   }
  # }

  guard::domain "yabai" "Ensure scripting addition is installed" && {
    shell::has yabai && {
      # reinstall the scripting addition
      sudo yabai --uninstall-sa
      sudo yabai --install-sa

      # load the scripting addition
      killall Dock || true

      sudo yabai --load-sa
    }
  }

}


guard::arch && {

  guard::domain "xmonad" "Rebuild Xmonad configurations" && {

    msg::subdomain "Install xmonad" && (
      cd "$XDG_CONFIG_HOME/xmonad"
      stack --allow-different-user install || {
        notify send -a "Eru" -t "Failed to compile xmonad" -u critical
      }
    )

    msg::subdomain "Restart xmonad" && {
      if pgrep d12-xmonad; then
        msg::info "Found running instance of xmonad. Restarting..."
        d12-xmonad --restart
      else
        msg::info "No running instance of xmonad is found. Meh..."
      fi
    }

  }
}


#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#:
#:    ==>   REALIZATION
#:
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>


msg::success "Bootstrapping complete!"

guard::install && {

  if ! shell::is_ci; then
    msg::warning "Restart!"
    msg::ask_for_confirmation "Restart?"

    if msg::is_confirmed; then
      sudo shutdown -r now &> /dev/null
    fi
  fi

}

msg::success "Everything is good here."

return

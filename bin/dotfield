#!/usr/bin/env bash
#
# dotfield
#
# Nix flake shortcuts.
#
# Usage:
#   dotfield <subcommand> [<args>...]
#   dotfield build [<flake-output>]
#   dotfield switch [<flake-output>]
#   dotfield evolve [<flake-output>]
#   dotfield repl [<flake-output>]

set -e

DOTFIELD_DIR="$(git rev-parse --show-toplevel)"

# shellcheck source=../lib/utils.sh
. "${DOTFIELD_DIR}/lib/utils.sh"

#========================================
# Swap a config directory pointing to a Nix store path with its corresponding
# directory in the flake configuration directory.
#
# Usage:
#   config::hotswap <src-dirname> [<dest-basepath>=$XDG_CONFIG_HOME]
# Parameters:
#   Source directory (from the flake config path) to link to the destination.
#   Destination basepath. The directory name itself will be identical to the source.
# Globals:
#   XDG_CONFIG_HOME
#   DOTFIELD_DIR
#========================================
function config::hotswap() {
  local swap_dir="$1"
  local dest_basepath="${2:-${XDG_CONFIG_HOME}}"

  local src="${DOTFIELD_DIR}/config/${swap_dir}"
  local dest="${dest_basepath}/${swap_dir}"
  local backup="${dest}.bak"
  local lockfile="${dest}.lock"

  [[ ! -d "${src}" ]] && {
    msg::error "Could not find a source directory at '${src}'"
  }

  [[ ! -d "${dest}" ]] && {
    msg::error "Could not find a target directory at '${dest}'"
  }

  msg::tabular_row "Source:" "${src}"
  msg::tabular_row "Target:" "${dest}"
  msg::tabular_row "Backup:" "${backup}"
  msg::tabular_row "Lockfile:" "${lockfile}"

  msg::ask_for_confirmation "Continue?"
  (! msg::is_confirmed) && \
    return 1

  if [[ -f "${lockfile}" ]]; then
    msg::warning "Restoring the original link to the Nix store..."
    msg::ask_for_confirmation "Continue?"
    (! msg::is_confirmed) && \
      return 1

    msg::info "Backing up the changed directory just in case..."
    mv -v "${dest}" "${dest}.changed.bak"

    msg::warning "Moving the old backup file back into place"
    mv -v "${backup}" "${dest}"

    msg::info "Disengaging swap lock"
    rm "${lockfile}"

    msg::success "Swap reverted!"
    msg::info "The destination path's original contents are restored."

  else
    [[ -a "${backup}" ]] && {
      msg::error "A backup file '${backup}' already exists!'"
    }

    [[ -a "${lockfile}" ]] && {
      msg::error "A lockfile file '${lockfile}' already exists!'"
    }

    msg::info "Backing up the destination path"
    mv -vi "${dest}" "${backup}"

    msg::info "Engaging swap lock"
    touch "${lockfile}"

    msg::warning "Linking the source directory to the destination"
    ln -s "${src}" "${dest}"

    msg::success "Swap complete!"
    msg::info "The destination path is now a symlink directly to the source path."
  fi

  msg::success "Done!"
}

#========================================
# Get an absolute path to a system flake output.
#
# Usage:
#   flake::output <name>
# Arguments:
#   Flake output name.
# Globals:
#   DOTFIELD_DIR
#========================================
function flake::output() {
  local output_name=$1
  printf "%s/#%s" "${DOTFIELD_DIR}" "${output_name}"
}

#========================================
# Output the current hostname, with fallback approaches.
#
# Usage:
#   host::name
# Globals:
#   DOTFIELD_HOSTNAME
#   HOSTNAME
#========================================
function host::name() {
  echo "${DOTFIELD_HOSTNAME:-${HOSTNAME:-$(hostname)}}"
}

#========================================
# Build a specified flake output.
#
# Usage:
#   host::build <name> [<args>...]
# Arguments:
#   Flake output name.
#   Args to pass to the build command.
#========================================
function host::build() {
  local output="$1"
  shift
  nix build --verbose "$(flake::output "${output}")" "$@"
}

#========================================
# Switch to a new generation.
#
# Usage:
#   host::switch <name> [<args>...]
# Arguments:
#   Flake output name.
#   Args to pass to the switch command.
# Globals:
#   DOTFIELD_DIR
#========================================
function host::switch() {
  local output="$1"

  shift

  "${DOTFIELD_DIR}/result/sw/bin/darwin-rebuild" switch --verbose --flake \
    "$(flake::output "${output}")" \
    "$@" ||
    {
      msg::error "Failed to switch to the new generation!"
    }
}

#========================================
# Whether a given string indicates a dark interface.
#
# Usage:
#   theme::is_dark <value>
# Arguments:
#   String to test
# Returns:
#   0 - Dark
#   1 - Light
#   2 - Invalid test value
#========================================
function theme::is_dark() {
  case "$1" in
    on | dark) return 0 ;;
    off | light) return 1 ;;
    *)
      msg::error "[theme::is_dark] Invalid option specified: ${1}"
      return 2
      ;;
  esac
}

#========================================
# Switch to a different system UI theme.
#
# Note: this function calls the main function recursively
# Usage:
#   theme::switch (light|dark|<theme-name>)
# Arguments:
#   Either "light", "dark", or a theme name.
#========================================
function theme::switch() {
  local name=$1
  if theme::is_dark "${name}"; then
    DOTFIELD_THEME="black-metal-khold"
  else
    DOTFIELD_THEME="grayscale-light"
  fi
  export DOTFIELD_THEME
  host::switch "$(host::name)" --impure
}

#========================================
# Open a new Nix REPL shell for a flake output.
#
# FIXME: assumes darwin
#
# Usage:
#   host::repl <output-name>
# Arguments:
#   Flake output name.
# Globals:
#   DOTFIELD_DIR
#========================================
function host::repl() {
  local output="$1"
  local conf
  conf="$(mktemp)"

  msg::subdomain "Loading flake from ${output}..."

  output="darwinConfigurations.${output}"

  cat >"${conf}" <<EOF
(builtins.getFlake (toString ${DOTFIELD_DIR})).${output}
EOF

  nix repl "${conf}"
}

#========================================
# Entry point.
#========================================
function main() {
  local subcommand="$1"
  local output

  shift

  output="$(host::name)"

  case "${subcommand}" in
    build)
      msg::domain "Evolution" "Building '${output}'"
      host::build "${output}" "$@"
      ;;

    switch)
      msg::domain "Evolution" "Switching to new generation"
      host::switch "${output}" "$@"
      ;;

    evolve)
      msg::domain "Evolution" "Building '${output}'"
      host::build "${output}"

      msg::domain "Evolution" "Switching to new generation"
      host::switch "${output}"
      ;;

    repl)
      msg::domain "Introspection" "Launching REPL shell for ${output}"
      host::repl "${output}"
      ;;

    hotswap)
      msg::domain "Teleportation" "Hotswapping config directory: ${swap_dir}"
      config::hotswap "$@"
      ;;

    theme)
      local theme="$1"
      msg::domain "Visualisation" "Changing color theme to '${theme}'"
      theme::switch "$@"
      ;;

    *)
      msg::error "[Error] Invalid subcommand ${subcommand}! Aborting."
      return 1
      ;;
  esac
}

main "$@"
